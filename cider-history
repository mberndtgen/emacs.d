;; -*- coding: utf-8-unix -*-
;; Automatically written history of CIDER REPL session
;; Edit at your own risk

("(app)














" "(macroexpand-1 '(when (= 2 2) (println \"It is four!\")))" "(macroexpand-1
     '(when (= 2 2) (println \"It is four!\")))" "(cons 'a 'b)" "(cons 1 2)" "(cons 'd (a b c))" "(cons 'd '(a b c))" "(cons 'do '(a b c))" "(cons 'do 'test)" ":cljs/quit" " (js/alert \"This is a browser connected REPL\")" "(js/alert \"This is a browser connected REPL\")" "(request-tea)" "(conj [] (repeat (rand-int 100) 1))" "(repeat (rand-int 100) 1)" "(rand-int 1000)" "tea-channel)" "tea-channel :hot-cup-of-tea)" "(async/go-loop []
                        (println \"Thanks for the \" (async/<! tea-channel))
                        (recur))" "(let [tea-channel (async/chan)]
                        (async/go (async/>! tea-channel :cup-of-tea-6))
                        (async/go (println \"Thanks for the \" (async/<! tea-channel))))" "(async/>!! tea-channel :cup-of-tea-5)" "(async/close! tea-channel)" "(async/>!! tea-channel :cup-of-tea-4)" "(async/>!! tea-channel :cup-of-tea-3)" "(async/>!! tea-channel :cup-of-tea-2)" "(async/>!! tea-channel :cup-of-tea)" "(async/<!! tea-channel)" "(async/>!! tea-channel :cup-of-tea)" "(def tea-channel (async/chan 10))" "(def tea-channel (async/chan))" "(require 'clojure.tools.nrepl)" "(require 'clojure.tools.namespace.repl)" "(require 'clojure.core)" "(csk/->snake_case \"hello manfred\")" ":" "?" "(help)" "?" "(:type {:type \"abc\"})" "{:type \"abc\"}" "(bite-left-side-simple \"regular\")" "(bite-left-side \"regular\")" "(bite-right-side alice-mushroom)" "(bite-left-side alice-mushroom)" "(.-height regular-mushroom)" "(.-color regular-mushroom)" "(class regular-mushroom)" "(eat-mushroom :grow)" "(eat-mushroom 10)" "(eat-mushroom \"Apple\")" "(eat-mushroom 10)" "(eat-mushroom 1)" "(who-are-you nil)" "(who-are-you true)" "(who-are-you 123)" "(who-are-you :me)" "(who-are-you \"me\")" "(.toString sb)" "(.toUpperCase \"abc\")" "(. \"Manfred\" toUpperCase)" "@who-agent" "who-agent" "(send who-agent agent-change)" "(restart-agent who-agent :caterpillar)" "(restart-agent who-agent)" "(agent-errors who-agent)" "(send who-agent agent-change)" "(send who-agent change-error)" "@who-agent" "(send who-agent change-error)" "@who-agent" "(send-off who-agent agent-change)" "@who-agent" "(send who-agent agent-change)" "@who-agent" "@y" "@x" "(let [n 2]
                   (future (dotimes [_ n] (new-values)))
                   (future (dotimes [_ n] (new-values))))" "@y" "@x" "(let [n 2]
                   (future (dotimes [_ n] (new-values)))
                   (future (dotimes [_ n] (new-values))))" "@alice-height" "(let [n 2]
                   (future (dotimes [_ n] (eat-from-right-hand)))
                   (future (dotimes [_ n] (eat-from-right-hand)))
                   (future (dotimes [_ n] (eat-from-right-hand))))" "@right-hand-bites" "@alice-height" "(let [n 2]
                   (future (dotimes [_ n] (eat-from-right-hand)))
                   (future (dotimes [_ n] (eat-from-right-hand)))
                   (future (dotimes [_ n] (eat-from-right-hand))))" "@right-hand-bites" "@alice-height" "(dosync (eat-from-right-hand))" "(eat-from-right-hand)" "(let [n 5]
                   (future (dotimes [_ n] (swap! counter inc-print)))
                   (future (dotimes [_ n] (swap! counter inc-print)))
                   (future (dotimes [_ n] (swap! counter inc-print)))
                   (future (dotimes [_ n] (swap! counter dec-print))))" "(let [n 5]
                   (future (dotimes [_ n] (swap! counter inc-print)))
                   (future (dotimes [_ n] (swap! counter inc-print)))
                   (future (dotimes [_ n] (swap! counter inc-print)))
                   (future (dotimes [_ n] (swap! counter dec))))" "@counter" "(reset! @counter 0)" "@counter" "(let [n 5]
                   (future (dotimes [_ n] (swap! counter inc)))
                   (future (dotimes [_ n] (swap! counter inc)))
                   (future (dotimes [_ n] (swap! counter inc)))
                   (future (dotimes [_ n] (swap! counter dec))))" "@counter" "(let [n 5]
                   (future (dotimes [_ n] (swap! counter inc)))
                   (future (dotimes [_ n] (swap! counter inc)))
                   (future (dotimes [_ n] (swap! counter inc)))
                   (future (dotimes [_ n] (swap! counter inc))))" "(let [n 5] )" "(let [n 5])" "@counter" "(def counter (atom 0))" "@who-atom" "(swap! who-atom change)" "(change :chrysalis)" "@who-atom" "(def who-atom (atom :caterpillar))" "(reset! who-atom :caterpillar)" "@who-atom" "(reset! who-atom :myself)" "@who-atom" "who-atom" "(def who-atom (atom :caterpillar))" "(name :a)" "(reduce (fn [r x] (+ r (* x x))) [1 2 3])" "(reduce (fn [rx] (+ r (* x x))) [1 2 3])" "(apply + [1 2 3])" "(take 3 (map #(str %) (range)))" "(map #(str %) animals)" "(countdown2 100000)" "(countdown 100000)" "(countdown 3)" "(let [{:keys [flower1 flower2] } {:flower1 \"red\" :flower2 \"blue\"}] (str \"The flowers are \" flower1 \" and \" flower2))" "(let [{:flower1 flower1 :flower2 flower2} {:flower1 \"red\" :flower2 \"blue\"}] (str \"The flowers are \" flower1 \" and \" flower2))" "(let [{flower1 :flower1 flower2 :flower2} {:flower1 \"red\" :flower2 \"blue\"}] (str \"The flowers are \" flower1 \" and \" flower2))" "(let [{flower1 :flower1 flower2 :flower2} {:flower1 \"red\" :flower2 \"blue\"}])" "(every? (fn [x] (< 1 x)) [3 5 6])" "(every? (fn [x] (< 10 x)) [1 3 5 6])" "(every? (fn [x] (odd? x)) [1 3 5 6])" "(every? (fn [x] (odd? x)) [1 3 5])" "(every? odd? [1 3 5 6])" "(every? odd? [1 3 5])" "(empty? nil)" " (class \"abc\")" " (class (seq \"abc\"))" "(seq \"abc\")" "(empty2? '())" "(empty? '())" "(empty '())" "(nil? nil)" "(nil? )" "(nil? false)" "(not= :a :b)" "(= '(:a :b) [:a :b])

" "(apply + [1 2 3])" "(common-fav-foods :a :v)" "(common-fav-foods ([:j1] [:j2]) )" "(common-fav-foods [:j1] [:j2] )" "(foo '(manfred))" "(foo 'manfred)" "(set [:a :b :c :b])" "(common-fav-foods [[:j1] [:j2]] )" "(common-fav-foods  [:jam1 :jam3])" "(common-fav-foods [:jam] [:jam3])" "(common-fav-foods [:jam :jam2] [:jam3 :jam2])" "*ns*" "(prn (fn [one two] (str \"Off we go\" \"!\" \" - \" one two) \"again\" \"?\"))" "(pr (fn [one two] (str \"Off we go\" \"!\" \" - \" one two) \"again\" \"?\"))" "((fn [one two] (str \"Off we go\" \"!\" \" - \" one two) \"again\" \"?\"))" "(fn [one two] (str \"Off we go\" \"!\" \" - \" one two) \"again\" \"?\")" "(fn [] (str \"Off we go\" \"!\" \" - \" %1 %2) \"again\" \"?\")" "(fn(str \"Off we go\" \"!\" \" - \" %1 %2) \"again\" \"?\")" "(#(str \"Off we go\" \"!\" \" - \" %1 %2) \"again\" \"?\")" "user/dev" "dev" "(def dev \"Anna\")" "(clojure.set/intersection #{:r :b :w} #{:w :p :y})" "(clojure.set/difference #{:r :b :w} #{:w :p :y})" "(clojure.set/union #{:r :b :w} #{:w :p :y})" "(assoc {:jam1 \"red\" :jam2 \"black\"} :jam1 \"orange\")" "(vals {:jam1 \"strawberry\" :jam2 \"blackberry\" :jam3 \"marmalade\"})" "(keys {:jam1 \"strawberry\" :jam2 \"blackberry\" :jam3 \"marmalade\"})" "(get {:jam1 \"strawberry\" :jam2 \"blackberry\" :jam3 \"marmalade\"} :jam2)" "(:jam2 {:jam1 \"strawberry\" :jam2 \"blackberry\" :jam3 \"marmalade\"})" "(conj '( :toast :butter) :jam :honey)" "(conj [:toast :butter] :jam :jamw)" "(conj [:toast :butter] :jam)" "(nth [:jar1 1 2 3 :jar2] 2)" "(nth [:jar1 1 2 3 :jar2] 0)" "(cons 4 (cons 5 nil))" "(cons 5 nil)" "(cons 4 '())" "ns wonderland.core")